import java.awt.*;
import java.awt.image.*;
import java.io.*;
import java.util.*;
import javax.imageio.*;

public class GameMap {
    private PerlinNoise heightGenerator;
    
    private Block[][] lastBiome;
    private Block[][] curBiome;
    private Block[][] nextBiome;
    private int[] maxHeights;
    public static final int BIOME_WIDTH = 200;			//200 blocks
    public static final int BIOME_HEIGHT = 50;			//50 blocks
    public static final int BLOCK_WIDTH = 50;			//50 pixels
    public static final int BLOCK_HEIGHT = 50;			//50 pixels
    private double xCaveFreq;
    private double yCaveFreq;
    private double xCave;
    private double yCave;
    private Random rand;
    private double topLevelSum;
    private int numTopLevels;
    private double avgTopLevel;
    private double xHeightFreq;
    private double xHeight;
    BufferedImage img;
    SubMap subMap;
    
    private StateManager sm;

    public GameMap(StateManager nsm) 
    {
    	makeBiome();
    	sm = nsm;
    	subMap = new SubMap(sm);
    }
    
    public SubMap getSubMap()
    {
    	return subMap;
    }
    
    //-----------------------------------------------------Terrain Generation----------------------------------------------------
    
    private void makeBiome()
    {
    	heightGenerator = new PerlinNoise(0.5, 4);
    	rand = new Random();
    	
    	curBiome = new Block[BIOME_WIDTH][];
    	
        for (int i = 0; i < curBiome.length; i++) {
            curBiome[i] = new Block[BIOME_HEIGHT];
        }
        
        //The max height of every column of blocks
        maxHeights = new int[BIOME_WIDTH];
        for (int i = 0; i < BIOME_WIDTH; i++)
        {
        	maxHeights[i] = -1;
        }
        
        //The starting position for the height generator and the frequency that the noise is sampled at
        xHeight = -rand.nextInt(1000000);
        xHeightFreq = 1.0 / (double)(rand.nextInt(40) + 80);
        
        //The frequencies for sampling noise for the cave generation
        this.xCaveFreq = 0.2;
        this.yCaveFreq = 0.25;
        
        //Starting position of the x-value for the cave noise sampling
        this.xCave = - this.rand.nextInt(Integer.MAX_VALUE);
        
        //Variables used to calculate the average height of the top level of dirt
        this.topLevelSum = 0.0;
        this.numTopLevels = 0;
        this.avgTopLevel = 0.0;
        
        int lastOrb = -1000;
        
        generateDirt();
        generateBridges();
        generateTrenchs();
        //generatePlatforms();
        generateCheckpoint();
        System.out.println("DONE");
        
        //Image used for testing
        img = new BufferedImage(BIOME_WIDTH * BLOCK_WIDTH, BIOME_HEIGHT * BLOCK_HEIGHT, 2);
        Graphics2D g = img.createGraphics();
        for (Block[] column : curBiome)
        {
        	for (Block b : column)
        	{
        		b.initialize(curBiome);
        		b.draw(g);
        	}
        }
        System.out.println("DONE");
        /*try {
            File outputfile = new File("biome.png");
            ImageIO.write((RenderedImage)img, "png", outputfile);
        }
        catch (IOException outputfile) {
            System.out.println("ERROR");
        }*/
    }
    
    private void generateDirt()
    {
        //Generates dirt
        for (int x = 0; x < BIOME_WIDTH; ++x, xHeight += xHeightFreq, xCave += xCaveFreq) 
        {
        	//The top level that the dirt will go to
            double topLevel = (int)(heightGenerator.getNoise(xHeight) * BIOME_HEIGHT * 0.6);
            
            topLevelSum += topLevel;
            ++numTopLevels;
            avgTopLevel = topLevelSum / (double) numTopLevels;
            yCave = 0.0;
            boolean lastWasAir = true;
            for (int y = 0; y < BIOME_HEIGHT; y++, yCave += yCaveFreq)
            {
                int n = (int)((SimplexNoise.octaveNoise2D(5, 0.1, 0.2, xCave, yCave) + 1.0) / 2.0 * 5.0);
                //Builds a dirt block if it is below the max height generated by the height generator and if there isnt a cave there
                if ((double)y >= topLevel && n > 1) 
                {
                	if (maxHeights[x] == -1)
                	{
                		maxHeights[x] = y;
                	}
                    curBiome[x][y] = new Dirt(x, y);

                    //Tries to build an orb if there is space above the dirt
                    try
                    {
                    	int r = rand.nextInt(5) + 4;
                    	/*if (lastWasAir && Math.abs(x - lastOrb) > 5 && curBiome[x][y - r].getColour() == Color.blue && rand.nextInt(20) == 0)
                    	{	//Orbs
                    		curBiome[x][y - r] = new Block(x, y - r, Color.yellow);
		                    g.setColor(Color.yellow);
		                    g.fillRect((x - 1) * BLOCK_WIDTH, (y - r - 1) * BLOCK_HEIGHT, BLOCK_WIDTH * 2, BLOCK_HEIGHT * 2);
		                    lastOrb = x;
                    	}*/
                    }
                    catch (IllegalArgumentException e) {}
                    catch (ArrayIndexOutOfBoundsException e) {}
                    
                    lastWasAir = false;
                } 
                else 
                {
                    curBiome[x][y] = new Air(x, y);
                    lastWasAir = true;
                }
            }
        }
    }

    private void generateBridges() {
        int numBridges = 2;														//The number of bridges to be generated
        ArrayList<Integer> heights = new ArrayList<Integer>(numBridges);		//The heights of each bridges
        
        //Goes through and generates each bridge
        for (int i = 0; i < numBridges; i++) 
        {
        	//First finds a value that is not too close to the bottom or top and does not hav the same height as any of the 
        	//previously made bridges
            int h;
            while (true) 
            {
                h = this.rand.nextInt(50 - (int)(this.topLevelSum / (double)this.numTopLevels) - 2) + (int)(this.topLevelSum / (double)this.numTopLevels) + 2;
                try {
                    for (Integer height : heights) {
                        if (Math.abs(height - h) >= 6) continue;
                        throw new Exception();
                    }
                    break;
                }
                catch (Exception n) {
                    continue;
                }
            }
            heights.add(h);
            
            
            boolean dirtR = curBiome[0][h].getType().equals("dirt");						//If the rightmost block is dirt
            boolean dirtL = curBiome[BIOME_WIDTH - 1][h].getType().equals("dirt");			//If the leftmost block is dirt
            boolean buildLadderR = true, buildLadderL = true;								//Attempts to prevent ladders from appearing right next to each other
            	
            //Builds the bridge from the left and from the right at the same time
            //Unless the first block on either side is dirt, it will not build the bridge from that side until it encounters dirt
            for (int lx = 0, rx = BIOME_WIDTH - 1; lx <= rx; lx++, rx--) 
            {
            	//Builds from the right
            	if (curBiome[rx][h].getType().equals("air")) 
                {
                    if (!dirtR) continue;			//If it hasn't reached dirt it doesn't build yet
                    if (buildLadderR)
                    {
                    	buildLadderR = !generateLadder(rx, h);
                    }
                    else							//If it couldn't build a ladder this block, the next one it will be able to
                    {
                    	buildLadderR = true;
                    }
                    
                    curBiome[rx][h] = new Bridge(rx, h);			//Current spot becomes a bridge block
                }
                else 
                {
                	dirtR = true;
                }
                
                //Builds from the left
                if (curBiome[lx][h].getType().equals("air")) 
                {
                    if (!dirtL) continue;			//If it hasn't reached dirt it doesn't build yet
                    if (buildLadderL)
                    {
                    	buildLadderL = !generateLadder(lx, h);
                    }
                    else
                    {
                    	buildLadderL = true;
                    }
                    
                    curBiome[lx][h] = new Bridge(lx, h);
                    continue;
                }
                else
                {
                	dirtL = true;
                }
            }
            mountExplosives(h);
        }
    }

    private boolean generateLadder(int x, int y) 
    {
    	boolean builtBridge = false;
    	if (rand.nextInt(5) == 0)
    	{
    		//Attempts to build a ladder towards the sky
    		//Will not build if:
    		//  � There is only air above it
    		//  � There was a ladder built up right next to it
    		//If it will build, it will build up until it reaches air or until it reaches a bridge
    		if (rand.nextBoolean())
    		{
    			boolean buildToSky = false;
    			//Checks to see if it can build up to a structure or if there is just air above it
	    		for (int i = y; i >= 0; i--)
	    		{
	    			String type = curBiome[x][i].getType();
	    			if (!type.equals("air"))				//If it has encountered a block other than dirt
	    			{
	    				buildToSky = true;					//A bridge can be built
	    				builtBridge = true;
	    				break;
	    			}
	    		}
	    		//Builds up if it can
	    		boolean reachedDirt = false;		//Will stop after the second patch of air that it reaches
	    		if (buildToSky)
	    		{
	    			for (int i = y - 1; i >= 0; i--)
		    		{
		    			//If it has reached a bridge it stops building
		    			if (curBiome[x][i].getType().equals("bridge"))
		    			{
		    				break;
		    			}
		    			//If it has traversed through a dirt section already and has reached air
		    			if (reachedDirt && curBiome[x][i].getType().equals("air"))
		    			{
		    				break;
		    			}
		    			
		    			if (curBiome[x][i].getType().equals("dirt"))
		    			{
		    				reachedDirt = true;
		    			}
		    			
		    			//Makes the ladder
		    			curBiome[x][i] = new Ladder(x, i);
		    		}
	    		}
    		}
    		if (rand.nextBoolean())
    		{
    			//Checks to see if it can build a ladder downwards
    			boolean hasDirt = false;
    			boolean hasAir = false;
    			for (int i = y + 3; i < BIOME_HEIGHT; i++)
    			{
    				if (curBiome[x][i].getType().equals("air"))
    				{
    					hasAir = true;
    				}
    				else if (curBiome[x][i].getType().equals("dirt"))
    				{
    					hasDirt = true;
    				}
    			}
    			
    			//If there is dirt and air such that it will travel through an air pocket and then stop on the dirt
    			if (hasDirt && hasAir)
    			{
    				builtBridge = true;
    				curBiome[x][y + 1] = new Ladder(x, y + 1);
                    curBiome[x][y + 2] = new Ladder(x, y + 2);
    				boolean reachedAir = false;
    				for (int i = y + 3; i < BIOME_HEIGHT; i++)
    				{
    					if ((reachedAir && curBiome[x][i].getType().equals("dirt")) || curBiome[x][i].getType().equals("bridge"))
    					{
    						builtBridge = true;
    						break;
    					}
    					if (curBiome[x][i].getType().equals("air"))
    					{
    						reachedAir = true;
    					}
    					curBiome[x][i] = new Ladder(x, i);
    				}
    			}
    			else if (hasDirt)
    			{
    				builtBridge = true;
    				int stopAt;
    				try
    				{
       					stopAt = rand.nextInt(BIOME_HEIGHT - y - 4) + y + 3;
    				}
    				catch (IllegalArgumentException e) { stopAt = y + 3; }
    				for (int i = y + 1; i <= stopAt; i++)
    				{
    					curBiome[x][i] = new Ladder(x, i);
    				}
    				int dir = rand.nextInt(1) * 2 - 1;
    				int curX = x + dir;
    				while (true)
    				{
    					if (curX < 0 || curX > BIOME_WIDTH || curBiome[curX][stopAt].getType().equals("air"))
    					{
    						break;
    					}
    					curBiome[curX][stopAt] = new Block(curX, stopAt, "air");
                    	curX += dir;
    				}
    			}
    		}
    	}
    	
    	return builtBridge;
    }
    
    private void mountExplosives(int startY)
    {
    	for (int x = 0; x < BIOME_WIDTH; x += 10)
    	{
    		if (!curBiome[x][startY].getType().equals("bridge")) continue;
    		for (int y = startY - 1; y > 0; y--)
    		{
    			String type = curBiome[x][y].getType();
    			if (type.equals("air")) continue;
    			else if (type.equals("dirt") && startY - y > 8)
    			{
    				mountExplosives(x, y + 1, (y + 1) + (startY - y) / 2, (y + 1) - (startY - y) / 2);
    			}
    			break;
    		}
    	}
    }
    
    private void mountExplosives(int x, int y, int maxY, int minY)
    {
    	if (y > maxY || y < minY || x == 0 || x == BIOME_WIDTH - 1 || !curBiome[x][y].getType().equals("air")) return;
    	
    	if (curBiome[x - 1][y].getType().equals("dirt") || curBiome[x + 1][y].getType().equals("dirt") ||
    		curBiome[x][y - 1].getType().equals("dirt") || curBiome[x][y + 1].getType().equals("dirt"))
    	{
    		curBiome[x][y] = new Explosive(x, y);
    		mountExplosives(x - 1, y, maxY, minY);
    		mountExplosives(x + 1, y, maxY, minY);
    		mountExplosives(x, y - 1, maxY, minY);
    		mountExplosives(x - 1, y + 1, maxY, minY);
    	}
    }
    
    private void generateTrenchs()
    {
    	for (int x = 10; x < BIOME_WIDTH - 10; x += rand.nextInt(8) + 5)
    	{
    		generateTrench(x);
    	}
    }
    
    private void generateTrench(int x)
    {
    	for (int y = 2; y < BIOME_HEIGHT - 7; y++)
    	{
    		//Checks to see if there is dirt surrounding the perimeter of trench to be built and air above for the enemies to be able to escape
    		if (curBiome[x][y].getType().equals("air") && curBiome[x][y + 1].getType().equals("air") &&		//If the space above it is air
    			curBiome[x + 1][y].getType().equals("air") && curBiome[x + 1][y + 1].getType().equals("air") &&
    			curBiome[x - 1][y + 2].getType().equals("dirt") && curBiome[x - 1][y + 3].getType().equals("dirt") && 
    			curBiome[x - 1][y + 4].getType().equals("dirt") && curBiome[x - 1][y + 5].getType().equals("dirt") &&
    			curBiome[x - 1][y + 6].getType().equals("dirt") && curBiome[x - 1][y + 7].getType().equals("dirt") &&
    			curBiome[x][y + 7].getType().equals("dirt") && curBiome[x + 1][y + 7].getType().equals("dirt") &&
    			curBiome[x + 2][y + 7].getType().equals("dirt") && curBiome[x + 3][y + 7].getType().equals("dirt") &&
    			curBiome[x + 4][y + 7].getType().equals("dirt") && curBiome[x + 5][y + 7].getType().equals("dirt") &&
    			curBiome[x + 6][y + 7].getType().equals("dirt") && curBiome[x + 6][y + 6].getType().equals("dirt") &&
    			curBiome[x + 6][y + 5].getType().equals("dirt") && curBiome[x + 6][y + 4].getType().equals("dirt") &&
    			curBiome[x + 6][y + 2].getType().equals("dirt") && curBiome[x + 5][y + 2].getType().equals("dirt") &&
    			curBiome[x + 4][y + 2].getType().equals("dirt") && curBiome[x + 3][y + 2].getType().equals("dirt") &&
    			curBiome[x + 2][y + 2].getType().equals("dirt"))	
    		{
    			//Changes the blocks so that they become appropriate blocks
    			//Goes column by column
       			curBiome[x][y + 2] = new Trench(x, y + 2, Trench.TOP_LEFT_CORNER);
       			curBiome[x][y + 3] = new Trench(x, y + 3, Trench.LEFT_WALL);
       			curBiome[x][y + 4] = new Trench(x, y + 4, Trench.LEFT_WALL);
       			curBiome[x][y + 5] = new Trench(x, y + 5, Trench.LEFT_WALL);
       			curBiome[x][y + 6] = new Trench(x, y + 6, Trench.BOTTOM_LEFT_CORNER);
       			
       			curBiome[x + 1][y + 2] = new Air(x + 1, y + 2);
       			curBiome[x + 1][y + 3] = new Air(x + 1, y + 3);
       			curBiome[x + 1][y + 4] = new Air(x + 1, y + 4);
       			curBiome[x + 1][y + 5] = new Air(x + 1, y + 5);
       			curBiome[x + 1][y + 6] = new Trench(x + 1, y + 6, Trench.BOTTOM_WALL);
       			
       			curBiome[x + 2][y + 2] = new Dirt(x + 2, y + 2);
       			curBiome[x + 2][y + 3] = new Trench(x + 2, y + 3, Trench.TOP_CENTER_CORNER);
       			curBiome[x + 2][y + 4] = new Air(x + 2, y + 4);
       			curBiome[x + 2][y + 5] = new Air(x + 2, y + 5);
       			curBiome[x + 2][y + 6] = new Trench(x + 2, y + 6, Trench.BOTTOM_WALL);
       			
       			curBiome[x + 3][y + 2] = new Dirt(x + 3, y + 2);
       			curBiome[x + 3][y + 3] = new Trench(x + 3, y + 3, Trench.TOP_WALL);
       			curBiome[x + 3][y + 4] = new Air(x + 3, y + 4);
       			curBiome[x + 3][y + 5] = new Air(x + 3, y + 5);
       			curBiome[x + 3][y + 6] = new Trench(x + 3, y + 6, Trench.SPAWNER_LEFT_SIDE);
       			
       			curBiome[x + 4][y + 2] = new Dirt(x + 4, y + 2);
       			curBiome[x + 4][y + 3] = new Trench(x + 4, y + 3, Trench.TOP_WALL);
       			curBiome[x + 4][y + 4] = new Air(x + 4, y + 4);
       			curBiome[x + 4][y + 5] = new Air(x + 4, y + 5);
       			curBiome[x + 4][y + 6] = new Trench(x + 4, y + 6, Trench.SPAWNER_RIGHT_SIDE);
       			
       			curBiome[x + 5][y + 2] = new Dirt(x + 5, y + 2);
       			curBiome[x + 5][y + 3] = new Trench(x + 5, y + 3, Trench.TOP_RIGHT_CORNER);
       			curBiome[x + 5][y + 4] = new Trench(x + 5, y + 4, Trench.RIGHT_WALL);
       			curBiome[x + 5][y + 5] = new Trench(x + 5, y + 5, Trench.RIGHT_WALL);
       			curBiome[x + 5][y + 6] = new Trench(x + 5, y + 6, Trench.BOTTOM_RIGHT_CORNER);
       			generateWatchTower(x + 1, y - 1);
       			y += 6;
       		}
    	}
    }
    
    private void generateWatchTower(int startX, int y)
    {	//This method finds the location to build the watchtower
    	//(startX, startY) is 2 blocks above the top block of the air column that has dirt on either side
    	int op = rand.nextInt(2) * 2 - 1; 	//Either + or - 1, checks either to the right or left of trench first randomly
    	for (int x = startX + 2 * op; Math.abs(x - startX) < 6; x += op)
    	{
    		boolean canBuild = true;
    		for (int ix = x; canBuild && Math.abs(x - ix) < 5; ix += op)
    		{
    			canBuild = curBiome[ix][y].isAir();
    		}
    		generateWatchTowerAt((op < 0) ? x - 4 : x, y);
    		return;
    	}
    }
    
    private void generateWatchTowerAt(int sx, int sy)
    {	//This method just generates the watchower
    	curBiome[sx][sy] = new Platform(sx, sy);
    	curBiome[sx + 1][sy] = new Platform(sx + 1, sy);
    	curBiome[sx + 2][sy] = new Platform(sx + 2, sy);
    	curBiome[sx + 3][sy] = new Platform(sx + 3, sy);
    	curBiome[sx + 4][sy] = new Platform(sx + 4, sy);
    	
    	//Creates the left column that supports the platform
    	for (int y = sy + 1; sy < BIOME_HEIGHT - 1; y++){
    		if (curBiome[sx][y].getType().equals("air")){
    			curBiome[sx][y].setSubType("pillar");
    		}
    		else break;
    	}
    	
    	//Creates the right column that supports the platform
    	for (int y = sy + 1; sy < BIOME_HEIGHT - 1; y++){
    		if (curBiome[sx + 4][y].getType().equals("air")){
    			curBiome[sx + 4][y].setSubType("pillar");
    		} else break;
    	}
    	
    	//Creates the left column that supports the roof
    	curBiome[sx][sy - 1] = new Air(sx, sy - 1, "pillar");
        curBiome[sx][sy - 2] = new Air(sx, sy - 2, "pillar");
		//Creates the right column that supports the roof
    	curBiome[sx + 4][sy - 1] = new Air(sx + 4, sy - 1, "pillar");
    	curBiome[sx + 4][sy - 2] = new Air(sx + 4, sy - 2, "pillar");
    	
    	//Fills the space in between with air
    	for (int x = sx + 1; x < sx + 4; x++) {
    		for (int y = sy - 1; y > sy - 3; y--) {
    			curBiome[x][y] = new Air(x, y);
    		}
    	}
    	
    	for (int x = sx; x < sx + 5; x++) {
    		for (int y = sy - 3; y > sy - 5; y--) {
    			curBiome[x][y] = new Roof(x, y);
    		}
    	}
    	Roof.initializeAt(curBiome, sx, sy - 4);
    }
    
    private void generatePlatforms()
    {
    	//Goes through every column of blocks
    	for (int x = 8; x < BIOME_WIDTH - 8; x += 2)
    	{
    		//Will try to build platforms between 6 blocks from the bottom of the map to 6 blocks above the highest piece of dirt on the map
    		int compareTo = Math.max(6, maxHeights[x] - 6);
    		for (int y = BIOME_HEIGHT - 6; y >= compareTo; y--)
    		{
    			//If there is 2 blocks of space above and below to build the platform
    			if (curBiome[x][y].isAir() && curBiome[x][y + 1].isAir() && curBiome[x][y + 2].isAir() && curBiome[x][y - 1].isAir() && curBiome[x][y - 2].isAir())
    			{
    				generatePlatform(x, y);
    			}
    		}
    	}
    }
    
    private void generatePlatform(int x, int y)
    {
    	int w = 1; 	//The width of the platform
    	for (int ix = x + 1; ix < x + 7; ix++)
    	{
    		//If there are 2 blocks of space above and below to build the platform
    		if (curBiome[ix][y].isAir() && curBiome[ix][y + 1].isAir() && curBiome[ix][y + 2].isAir() && curBiome[ix][y - 1].isAir() && curBiome[ix][y - 2].isAir())
    		{
    			w++;
    		}
    		else break;
    	}
    	
    	//Platform must be at least 4 blocks wide and for every 10 places that there can be a platform, only 1 will be built
    	if (w < 4 || rand.nextInt(25) != 0) return;
    	
    	for (int ix = x; ix < x + w; ix++)
    	{
    		curBiome[ix][y] = new Platform(ix, y);
    	}
    }
    
    private void generateCheckpoint()
    {	//Tries to build a checkpoint the closest it can to the top right corner of the map
    	for (int x = BIOME_WIDTH - 5; x > 0; x--) {
    		for (int y = 7; y < BIOME_HEIGHT / 2; y++) {
    			if (!curBiome[x][y].getType().equals("air")) {
    				generateCheckpointAt(x, y);
    				return;
    			}
    		}
    	}
    }
    
    private void generateCheckpointAt(int x, int y)
    {
    	//Makes sure there is a block below the platform
    	for (int ix = x; ix < x + 3; ix++) {
    		if (curBiome[ix][y].getType().equals("air")) {
    			curBiome[ix][y] = new Dirt(ix, y);
    		}
    	}
    	//Build the base
    	for (int i = 0; i < 3; i++) {
    		curBiome[x + i][y - 1] = new Bridge(x + i, y - 1, Bridge.CHECKPOINT_BASE[i]);
    	}
    	//Builds the tower
    	for (int i = 0; i < 5; i++) {
    		curBiome[x + 1][y - 2 - i] = new Air(x + 1, y - 2 - i, "checkpoint", Air.CHECKPOINT_TOWER[i]);
    	}
    	//Adds the flashing lights
    	curBiome[x][y - 2] = new FlashingLight(x, y - 2);
    	curBiome[x][y - 2].setImages(FlashingLight.CHECKPOINT_LEFT_RED);
    	curBiome[x + 2][y - 2] = new FlashingLight(x + 2, y - 2);
    	curBiome[x + 2][y - 2].setImages(FlashingLight.CHECKPOINT_RIGHT_RED);
    	curBiome[x + 1][y - 7] = new FlashingLight(x + 1, y - 7);
    	curBiome[x + 1][y - 7].setImages(FlashingLight.CHECKPOINT_TOP_RED);
    }
    
    //-----------------------------------------------------------------------------------------------------------------------------
    
    //------------------------------------------------------------Drawing----------------------------------------------------------
    public void updateSubMap(Graphics g, LinkedList<Player> players)
    {	//Updates the SubMap so the the image encompasses all of the players
    	double numPlayers = (double) players.size();
    	int sumX = 0;		//The sums of the coordinates of the player 
    	int sumY = 0;
    	
    	for (Player p : players)	//Adds the coordinates of each player
    	{
    		sumX += p.getX();
    		sumY += p.getY();
    	}
    	
    	int avgX = (int)((double)sumX / numPlayers);		//The average position of the player
    	int avgY = (int)((double)sumY / numPlayers);
    	
    	int maxDistSq = 0;						//The max distance between the avg pos and a player
    	int maxX = 0; int maxY = 0;					//That player's position
    	int dx = 0; int dy = 0;							//The distance between the avg pos and the player pos
    	for (Player p : players)				//Goes through each player to see which one is the furthest from the average
    	{ 
    		int tx = p.getIntX();
    		int ty = p.getIntY();
    		dx = avgX - tx;
    		dy = avgY - ty;
    		int curDistSq = (dx) * (dx) + (dy) * (dy);		//The distance squared between the avg and player
    		if (curDistSq > maxDistSq)
    		{
    			maxDistSq = curDistSq;
    			maxX = tx; maxY = ty;
    		}
    	}
    	int lx, ly, width, height;
    	if (Math.abs(maxY - avgY) >= Math.abs(maxX - avgX))	//If the y-dist from avgY is greater than the x-dist from avgY
    	{
    		height = 2 * (Math.abs(dy) + 6 * BLOCK_HEIGHT);						//The height of the img is calculated first
    		width = (int)((sm.getWidth() / (double)sm.getHeight()) * height);	//And width is scaled after so that it holds the same
    																			//Resolution ratio of the screen
    	}
    	else
    	{
    		width = 2 * (Math.abs(dx) + 6 * BLOCK_WIDTH);
    		height = (int)((sm.getHeight() / (double)sm.getWidth()) * width);
    	}
    	
    	//Calculates the top-left coord of the img
    	lx = Math.min(Math.max(0, avgX - width / 2), BIOME_WIDTH * BLOCK_WIDTH - width);
    	ly = Math.min(Math.max(0, avgY - height / 2), BIOME_HEIGHT * BLOCK_HEIGHT - height);
    	if (lx < 0) lx = 0;									//Handles special cases when the map is very zoomed out
    	if (ly < 0) ly = 0;
    	width = Math.min(width, BIOME_WIDTH * BLOCK_WIDTH - 1);
    	height = Math.min(height, BIOME_HEIGHT * BLOCK_HEIGHT - 1);
    	
    	//Updates the SubMap
    	subMap.setAll(lx, ly, width, height, ImageTools.copy(img.getSubimage(lx, ly, width, height)), (double) sm.getWidth() / width, (double) sm.getHeight() / height);
    }

    public static void main(String[] args) {
        new GameMap(null);
    }
}

//This class contains the portion of the GameMap that will be drawn on the screen at the current frame
//It allows other classes to draw their objects onto the current screen frame at their real size before the SubMap
//Is scaled down to fit on the screen
class SubMap extends Rectangle
{
	private BufferedImage img;							//The sub-image of GameMap.img which contains all of the players in it
	private double scrollFactorX, scrollFactorY;		//The amount by which to scale the image to fit it onto the screen
	private StateManager sm;							//The JFrame of the game, used to get the resolution of the screen
	private Graphics g;									//The Graphics object to draw on the img
	
	public SubMap(StateManager s)
	{
		super(0, 0, 0, 0);
		sm = s;
	}
	
	public void setAll(int nx, int ny, int nw, int nh, BufferedImage bi, double sfx, double sfy)
	{	//Called every frame when GameMap is done calculating what of the game map is to be drawn that frame
		x = nx; y = ny; width = nw; height = nh; img = bi; scrollFactorX = sfx; scrollFactorY = sfy; g = bi.getGraphics();
	}
	
	public int getIntX()	{	return x;	}						//Returns the top left corner of the img relative to the entire			
    public int getIntY()	{	return y;	}						//Game map
    public int getIntWidth()	{	return width;	}
    public int getIntHeight()	{	return height;	}				//Rectangle.getX(), etc... return doubles, removes the pain of having
    public BufferedImage getImg()	{	return img;	}				//To cast it down to an int
    public Graphics getGraphics()	{	return g;	}
	
	public BufferedImage getScaledImg()
	{	//Returns the image scaled such that it will fit completely on the screen
		return ImageTools.scale(img, (double) sm.getWidth() / width, (double) sm.getHeight() / height);
	}
}