//Michal Jez
//04/05/2016
//This file contains 2 classes: GameMap for creating the map and SubMap for drawing the portion of the map to be displayed a given frame

import java.awt.*;
import java.awt.image.*;
import java.io.*;
import java.util.*;
import javax.imageio.*;

//This class creates the GameMap and also provides the game with methods of getting where to spawn players by analyzing where they currently are
//It also spawns enemies too
//The terrain is generated by:
//  1. Calculating the highest point of dirt at a specific x-coordinate using 1D Perlin Noise
//  2. Adding caves using 2D Simplex Noise
//  3. Generates bridges
//  4. Generate ladders extending from bridges
//  5. Generate trenches and their accompanying watch towers
//  6. Generates boxes randomly on the map
//  7. Generates explosives randomly on the map
//  8. Generates the start point for the game
//  9. Generates the checkpoint at the end of the map
//  10. Generates the Enemies on the map

public class GameMap {
    private PerlinNoise heightGenerator;

    private Block[][] lastBiome;
    private Block[][] curBiome;
    private Block[][] nextBiome;
    private int[] maxHeights;
    public static final int BIOME_WIDTH = 200;			//200 blocks
    public static final int BIOME_HEIGHT = 50;			//50 blocks
    public static final int BLOCK_WIDTH = 50;			//50 pixels
    public static final int BLOCK_HEIGHT = 50;			//50 pixels
    private double xCaveFreq;
    private double yCaveFreq;
    private double xCave;
    private double yCave;
    private Random rand;
    private double topLevelSum;
    private int numTopLevels;
    private double avgTopLevel;
    private double xHeightFreq;
    private double xHeight;
    private BufferedImage img;				//The image of the map
    private SubMap subMap;
    private FlashingBlocks flashingBlocks;
    private Rectangle checkpointRect;						//Where a player has to be to reach the checkpoint
    private boolean hasReachedCheckpoint = false;			//If a player has made it to the checkpoint
    private Point[] checkpointLights;						//The flashing lights of the checkpoint

    private HashMap<Long, Enemy> enemies;

    private int spawnX, spawnY;				//The location where players spawn at the start of the game

    private Graphics g;

    private StateManager sm;

    public GameMap(StateManager nsm)
    {
        flashingBlocks = new FlashingBlocks(this);
        enemies = new HashMap<Long, Enemy>();
        makeBiome();
        sm = nsm;
        subMap = new SubMap(sm);



        g = null;
    }

    public SubMap getSubMap()
    {
        return subMap;
    }

    private static void pause(int time)
    {	/*
            Pauses the program for the given time
            During terrain generation, some enemies may be spawned with a time interval between them of <1 ms
            This will cause multiple enemies to have the same creation time which is unwanted because both of them may be removed from the HashMap
        */
        try {
            Thread.sleep(time);
        } catch(InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }

    //-----------------------------------------------------Terrain Generation----------------------------------------------------

    private void makeBiome()
    {	//Creates the current biome
        //First initializes the terrain generators and the array of arrays that holds the game map

        heightGenerator = new PerlinNoise(0.5, 4);				//Used to generate the max height of a dirt block for a given x-value
        rand = new Random();

        //Initializes the Array of Arrays that holds every block in the game
        curBiome = new Block[BIOME_WIDTH][];

        for (int i = 0; i < curBiome.length; i++) {
            curBiome[i] = new Block[BIOME_HEIGHT];
        }

        //The max height of every column of blocks
        maxHeights = new int[BIOME_WIDTH];
        for (int i = 0; i < BIOME_WIDTH; i++)
        {
            maxHeights[i] = -1;
        }

        //The starting position for the height generator and the frequency that the noise is sampled at
        xHeight = -rand.nextInt(1000000);
        xHeightFreq = 1.0 / (double)(rand.nextInt(40) + 80);

        //The frequencies for sampling noise for the cave generation
        this.xCaveFreq = 0.2;
        this.yCaveFreq = 0.25;

        //Starting position of the x-value for the cave noise sampling
        this.xCave = - this.rand.nextInt(Integer.MAX_VALUE);

        //Variables used to calculate the average height of the top level of dirt
        this.topLevelSum = 0.0;
        this.numTopLevels = 0;
        this.avgTopLevel = 0.0;

        int lastOrb = -1000;

        generateDirt();                     //Generates the blank dirt
        generateBridges();                  //Then the bridges
        generateTrenchs();                  //Then the trenches
        //generatePlatforms();
        generateBoxes();                    //Then the boxes
        generateExplosives();               //Then random explosives
        generateStartingPoint();            //Then the starting point
        generateCheckpoint();               //Then the checkpoint
        generateEnemySoldiers();

        //Image used for testing
        img = new BufferedImage(BIOME_WIDTH * BLOCK_WIDTH, BIOME_HEIGHT * BLOCK_HEIGHT, 2);
        g = img.getGraphics();
        for (Block[] column : curBiome)
        {
            for (Block b : column)
            {
                b.initialize(curBiome);
                b.draw(g);
            }
        }
        /*try {
            File outputfile = new File("biome.png");
            ImageIO.write((RenderedImage)img, "png", outputfile);
        }
        catch (IOException outputfile) {
            System.out.println("ERROR");
        }*/
    }

    private void generateDirt()
    {	//Generates dirt
        for (int x = 0; x < BIOME_WIDTH; ++x, xHeight += xHeightFreq, xCave += xCaveFreq)
        {
            //The top level that the dirt will go to
            double topLevel = (int)(heightGenerator.getNoise(xHeight) * BIOME_HEIGHT * 0.6);

            topLevelSum += topLevel;
            ++numTopLevels;
            avgTopLevel = topLevelSum / (double) numTopLevels;
            yCave = 0.0;
            boolean lastWasAir = true;
            for (int y = 0; y < BIOME_HEIGHT; y++, yCave += yCaveFreq)
            {
                int n = (int)((SimplexNoise.octaveNoise2D(5, 0.1, 0.2, xCave, yCave) + 1.0) / 2.0 * 5.0);
                //Builds a dirt block if it is below the max height generated by the height generator and if there isnt a cave there
                if ((double)y >= topLevel && n > 1)
                {
                    if (maxHeights[x] == -1)
                    {
                        maxHeights[x] = y;
                    }
                    curBiome[x][y] = new Dirt(x, y);

                    //Tries to build an orb if there is space above the dirt
                    try
                    {
                        int r = rand.nextInt(5) + 4;
                    	/*if (lastWasAir && Math.abs(x - lastOrb) > 5 && curBiome[x][y - r].getColour() == Color.blue && rand.nextInt(20) == 0)
                    	{	//Orbs
                    		curBiome[x][y - r] = new Block(x, y - r, Color.yellow);
		                    g.setColor(Color.yellow);
		                    g.fillRect((x - 1) * BLOCK_WIDTH, (y - r - 1) * BLOCK_HEIGHT, BLOCK_WIDTH * 2, BLOCK_HEIGHT * 2);
		                    lastOrb = x;
                    	}*/
                    }
                    catch (IllegalArgumentException e) {}
                    catch (ArrayIndexOutOfBoundsException e) {}

                    lastWasAir = false;
                }
                else
                {
                    curBiome[x][y] = new Air(x, y);
                    lastWasAir = true;
                }
            }
        }
    }

    private void generateBridges()
    {   /*
            Generates the bridges in the biome
        */
        int numBridges = 2;														//The number of bridges to be generated
        ArrayList<Integer> heights = new ArrayList<Integer>(numBridges);		//The heights of each bridges

        //Goes through and generates each bridge
        for (int i = 0; i < numBridges; i++)
        {
            //First finds a value that is not too close to the bottom or top and does not hav the same height as any of the
            //previously made bridges
            int h;
            while (true)
            {
                h = this.rand.nextInt(50 - (int)(this.topLevelSum / (double)this.numTopLevels) - 2) + (int)(this.topLevelSum / (double)this.numTopLevels) + 2;
                try {
                    for (Integer height : heights) {
                        if (Math.abs(height - h) >= 6) continue;
                        throw new Exception();
                    }
                    break;
                }
                catch (Exception n) {
                    continue;
                }
            }
            heights.add(h);


            boolean dirtR = curBiome[0][h].getType().equals("dirt");						//If the rightmost block is dirt
            boolean dirtL = curBiome[BIOME_WIDTH - 1][h].getType().equals("dirt");			//If the leftmost block is dirt
            boolean buildLadderR = true, buildLadderL = true;								//Attempts to prevent ladders from appearing right next to each other

            //Builds the bridge from the left and from the right at the same time
            //Unless the first block on either side is dirt, it will not build the bridge from that side until it encounters dirt
            for (int lx = 0, rx = BIOME_WIDTH - 1; lx <= rx; lx++, rx--)
            {
                //Builds from the right
                if (curBiome[rx][h].getType().equals("air"))
                {
                    if (!dirtR) continue;			//If it hasn't reached dirt it doesn't build yet
                    if (buildLadderR)
                    {
                        buildLadderR = !generateLadder(rx, h);
                    }
                    else							//If it couldn't build a ladder this block, the next one it will be able to
                    {
                        buildLadderR = true;
                    }

                    curBiome[rx][h] = new Bridge(rx, h);			//Current spot becomes a bridge block
                }
                else
                {
                    dirtR = true;
                }

                //Builds from the left
                if (curBiome[lx][h].getType().equals("air"))
                {
                    if (!dirtL) continue;			//If it hasn't reached dirt it doesn't build yet
                    if (buildLadderL)
                    {
                        buildLadderL = !generateLadder(lx, h);
                    }
                    else
                    {
                        buildLadderL = true;
                    }

                    curBiome[lx][h] = new Bridge(lx, h);
                    continue;
                }
                else
                {
                    dirtL = true;
                }
            }
            mountExplosives(h);
        }
    }

    private boolean generateLadder(int x, int y)
    {   /*
            Generates the ladders extending from the bridges
        */
        boolean builtBridge = false;
        if (rand.nextInt(5) == 0)
        {
            //Attempts to build a ladder towards the sky
            //Will not build if:
            //  - There is only air above it
            //  - There was a ladder built up right next to it
            //If it will build, it will build up until it reaches air or until it reaches a bridge
            if (rand.nextBoolean())
            {
                boolean buildToSky = false;
                //Checks to see if it can build up to a structure or if there is just air above it
                for (int i = y; i >= 0; i--)
                {
                    String type = curBiome[x][i].getType();
                    if (!type.equals("air"))				//If it has encountered a block other than dirt
                    {
                        buildToSky = true;					//A bridge can be built
                        builtBridge = true;
                        break;
                    }
                }
                //Builds up if it can
                boolean reachedDirt = false;		//Will stop after the second patch of air that it reaches
                if (buildToSky)
                {
                    for (int i = y - 1; i >= 0; i--)
                    {
                        //If it has reached a bridge it stops building
                        if (curBiome[x][i].getType().equals("bridge"))
                        {
                            break;
                        }
                        //If it has traversed through a dirt section already and has reached air
                        if (reachedDirt && curBiome[x][i].getType().equals("air"))
                        {
                            break;
                        }

                        if (curBiome[x][i].getType().equals("dirt"))
                        {
                            reachedDirt = true;
                        }

                        //Makes the ladder
                        curBiome[x][i] = new Ladder(x, i);
                    }
                }
            }
            if (rand.nextBoolean())
            {
                //Checks to see if it can build a ladder downwards
                boolean hasDirt = false;
                boolean hasAir = false;
                for (int i = y + 3; i < BIOME_HEIGHT; i++)
                {
                    if (curBiome[x][i].getType().equals("air"))
                    {
                        hasAir = true;
                    }
                    else if (curBiome[x][i].getType().equals("dirt"))
                    {
                        hasDirt = true;
                    }
                }

                //If there is dirt and air such that it will travel through an air pocket and then stop on the dirt
                if (hasDirt && hasAir)
                {
                    builtBridge = true;
                    curBiome[x][y + 1] = new Ladder(x, y + 1);
                    curBiome[x][y + 2] = new Ladder(x, y + 2);
                    boolean reachedAir = false;
                    for (int i = y + 3; i < BIOME_HEIGHT; i++)
                    {
                        if ((reachedAir && curBiome[x][i].getType().equals("dirt")) || curBiome[x][i].getType().equals("bridge"))
                        {
                            builtBridge = true;
                            break;
                        }
                        if (curBiome[x][i].getType().equals("air"))
                        {
                            reachedAir = true;
                        }
                        curBiome[x][i] = new Ladder(x, i);
                    }
                }
                else if (hasDirt)
                {
                    builtBridge = true;
                    int stopAt;
                    try
                    {
                        stopAt = rand.nextInt(BIOME_HEIGHT - y - 4) + y + 3;
                    }
                    catch (IllegalArgumentException e) { stopAt = y + 3; }
                    for (int i = y + 1; i <= stopAt; i++)
                    {
                        curBiome[x][i] = new Ladder(x, i);
                    }
                    int dir = rand.nextInt(1) * 2 - 1;
                    int curX = x + dir;
                    while (true)
                    {
                        if (curX < 0 || curX > BIOME_WIDTH || curBiome[curX][stopAt].getType().equals("air"))
                        {
                            break;
                        }
                        curBiome[curX][stopAt] = new Block(curX, stopAt, "air");
                        curX += dir;
                    }
                }
            }
        }

        return builtBridge;
    }

    private void mountExplosives(int startY)
    {   /*
            Finds a location to mount explosives
        */
        for (int x = 0; x < BIOME_WIDTH; x += 10)
        {
            if (!curBiome[x][startY].getType().equals("bridge")) continue;
            for (int y = startY - 1; y > 0; y--)
            {
                String type = curBiome[x][y].getType();
                if (type.equals("air")) continue;
                else if (type.equals("dirt") && startY - y > 8)
                {
                    mountExplosives(x, y + 1, (y + 1) + (startY - y) / 2, (y + 1) - (startY - y) / 2);
                }
                break;
            }
        }
    }

    private void mountExplosives(int x, int y, int maxY, int minY)
    {   /*
            Recursively generates explosives around a cave top
        */
        if (y > maxY || y < minY || x == 0 || x == BIOME_WIDTH - 1 || !curBiome[x][y].getType().equals("air")) return;

        if (curBiome[x - 1][y].getType().equals("dirt") || curBiome[x + 1][y].getType().equals("dirt") ||
                curBiome[x][y - 1].getType().equals("dirt") || curBiome[x][y + 1].getType().equals("dirt"))
        {
            curBiome[x][y] = new Explosive(x, y);
            mountExplosives(x - 1, y, maxY, minY);
            mountExplosives(x + 1, y, maxY, minY);
            mountExplosives(x, y - 1, maxY, minY);
            mountExplosives(x - 1, y + 1, maxY, minY);
        }
    }

    private void generateTrenchs()
    {	//Jumps a few blocks every time and checks to see if a trench can be built at that x-value
        for (int x = 20; x < BIOME_WIDTH - 15; x += rand.nextInt(8) + 2)
        {
            generateTrench(x);
        }
    }

    private void generateTrench(int x)
    {	//A trench is a predefined structure and will only be built if the nearby terrain can be molded around the trench
        for (int y = 2; y < BIOME_HEIGHT - 10; y++)
        {
            //Checks to see if there is dirt surrounding the perimeter of trench to be built and air above for the enemies to be able to escape
            if (curBiome[x][y].getType().equals("air") && curBiome[x][y + 1].getType().equals("air") &&		//If the space above it is air
                    curBiome[x + 1][y].getType().equals("air") && curBiome[x + 1][y + 1].getType().equals("air") &&
                    curBiome[x - 1][y + 2].getType().equals("dirt") && curBiome[x - 1][y + 3].getType().equals("dirt") &&
                    curBiome[x - 1][y + 4].getType().equals("dirt") && curBiome[x - 1][y + 5].getType().equals("dirt") &&
                    curBiome[x - 1][y + 6].getType().equals("dirt") && curBiome[x - 1][y + 7].getType().equals("dirt") &&
                    curBiome[x][y + 7].getType().equals("dirt") && curBiome[x + 1][y + 7].getType().equals("dirt") &&
                    curBiome[x + 2][y + 7].getType().equals("dirt") && curBiome[x + 3][y + 7].getType().equals("dirt") &&
                    curBiome[x + 4][y + 7].getType().equals("dirt") && curBiome[x + 5][y + 7].getType().equals("dirt") &&
                    curBiome[x + 6][y + 7].getType().equals("dirt") && curBiome[x + 6][y + 6].getType().equals("dirt") &&
                    curBiome[x + 6][y + 5].getType().equals("dirt") && curBiome[x + 6][y + 4].getType().equals("dirt") &&
                    curBiome[x + 6][y + 2].getType().equals("dirt") && curBiome[x + 5][y + 2].getType().equals("dirt") &&
                    curBiome[x + 4][y + 2].getType().equals("dirt") && curBiome[x + 3][y + 2].getType().equals("dirt") &&
                    curBiome[x + 2][y + 2].getType().equals("dirt"))
            {
                //Changes the blocks so that they become appropriate blocks
                //Goes column by column
                curBiome[x][y + 2] = new Trench(x, y + 2, Trench.TOP_LEFT_CORNER);
                curBiome[x][y + 3] = new Trench(x, y + 3, Trench.LEFT_WALL);
                curBiome[x][y + 4] = new Trench(x, y + 4, Trench.LEFT_WALL);
                curBiome[x][y + 5] = new Trench(x, y + 5, Trench.LEFT_WALL);
                curBiome[x][y + 6] = new Trench(x, y + 6, Trench.BOTTOM_LEFT_CORNER);

                curBiome[x + 1][y + 2] = new Air(x + 1, y + 2);
                curBiome[x + 1][y + 3] = new Air(x + 1, y + 3);
                curBiome[x + 1][y + 4] = new Air(x + 1, y + 4);
                curBiome[x + 1][y + 5] = new Air(x + 1, y + 5);
                curBiome[x + 1][y + 6] = new Trench(x + 1, y + 6, Trench.BOTTOM_WALL);

                curBiome[x + 2][y + 2] = new Dirt(x + 2, y + 2);
                curBiome[x + 2][y + 3] = new Trench(x + 2, y + 3, Trench.TOP_CENTER_CORNER);
                curBiome[x + 2][y + 4] = new Air(x + 2, y + 4);
                curBiome[x + 2][y + 5] = new Air(x + 2, y + 5);
                curBiome[x + 2][y + 6] = new Trench(x + 2, y + 6, Trench.BOTTOM_WALL);

                curBiome[x + 3][y + 2] = new Dirt(x + 3, y + 2);
                curBiome[x + 3][y + 3] = new Trench(x + 3, y + 3, Trench.TOP_WALL);
                curBiome[x + 3][y + 4] = new Air(x + 3, y + 4);
                curBiome[x + 3][y + 5] = new Air(x + 3, y + 5);

                Spawner spawner = new Spawner(x + 3, y + 6, Spawner.SLOW);          //The spawner is 2 blocks wide
                curBiome[x + 3][y + 6] = spawner;
                curBiome[x + 4][y + 6] = spawner;

                curBiome[x + 4][y + 2] = new Dirt(x + 4, y + 2);
                curBiome[x + 4][y + 3] = new Trench(x + 4, y + 3, Trench.TOP_WALL);
                curBiome[x + 4][y + 4] = new Air(x + 4, y + 4);
                curBiome[x + 4][y + 5] = new Air(x + 4, y + 5);

                curBiome[x + 5][y + 2] = new Dirt(x + 5, y + 2);
                curBiome[x + 5][y + 3] = new Trench(x + 5, y + 3, Trench.TOP_RIGHT_CORNER);
                curBiome[x + 5][y + 4] = new Trench(x + 5, y + 4, Trench.RIGHT_WALL);
                curBiome[x + 5][y + 5] = new Trench(x + 5, y + 5, Trench.RIGHT_WALL);
                curBiome[x + 5][y + 6] = new Trench(x + 5, y + 6, Trench.BOTTOM_RIGHT_CORNER);
                generateWatchTower(x + 1, y - 1, spawner);
                y += 6;
            }
        }
    }

    private void generateWatchTower(int startX, int y, Spawner spawner)
    {	//This method finds the location to build the watchtower
        //(startX, startY) is 2 blocks above the top block of the air column that has dirt on either side
        int op = rand.nextInt(2) * 2 - 1; 	//Either + or - 1, checks either to the right or left of trench first randomly
        for (int x = startX + 2 * op; Math.abs(x - startX) < 6; x += op)
        {
            boolean canBuild = true;
            for (int ix = x; canBuild && Math.abs(x - ix) < 5; ix += op)
            {
                canBuild = curBiome[ix][y].isAir();
            }
            generateWatchTowerAt((op < 0) ? x - 4 : x, y, spawner);
            return;
        }
    }

    private void generateWatchTowerAt(int sx, int sy, Spawner spawner)
    {	//This method just generates the watchtower
        try {
            Enemy e = new EnemyCommander(sx * BLOCK_WIDTH, sy * BLOCK_HEIGHT, spawner);
            enemies.put(e.creationTime, e);
            pause(5);
        } catch (ExceptionInInitializerError e) {}
        curBiome[sx][sy] = new Platform(sx, sy, Platform.SubType.WATCH_TOWER);
        curBiome[sx + 1][sy] = new Platform(sx + 1, sy, Platform.SubType.WATCH_TOWER);
        curBiome[sx + 2][sy] = new Platform(sx + 2, sy, Platform.SubType.WATCH_TOWER);
        curBiome[sx + 3][sy] = new Platform(sx + 3, sy, Platform.SubType.WATCH_TOWER);
        curBiome[sx + 4][sy] = new Platform(sx + 4, sy, Platform.SubType.WATCH_TOWER);

        //Creates the left column that supports the platform
        for (int y = sy + 1; sy < BIOME_HEIGHT - 1; y++){
            try {
                if (curBiome[sx][y].getType().equals("air")) {
                    curBiome[sx][y].setSubType("pillar");
                }
                else break;
            } catch(IndexOutOfBoundsException e) {}
        }

        //Creates the right column that supports the platform
        for (int y = sy + 1; sy < BIOME_HEIGHT - 1; y++){
            if (curBiome[sx + 4][y].getType().equals("air")){
                curBiome[sx + 4][y].setSubType("pillar");
            } else break;
        }

        //Creates the left column that supports the roof
        curBiome[sx][sy - 1] = new Air(sx, sy - 1, "pillar");
        curBiome[sx][sy - 2] = new Air(sx, sy - 2, "pillar");
        //Creates the right column that supports the roof
        curBiome[sx + 4][sy - 1] = new Air(sx + 4, sy - 1, "pillar");
        curBiome[sx + 4][sy - 2] = new Air(sx + 4, sy - 2, "pillar");

        //Fills the space in between with air
        for (int x = sx + 1; x < sx + 4; x++) {
            for (int y = sy - 1; y > sy - 3; y--) {
                curBiome[x][y] = new Air(x, y);
            }
        }

        for (int x = sx; x < sx + 5; x++) {
            for (int y = sy - 3; y > sy - 5; y--) {
                curBiome[x][y] = new Roof(x, y);
            }
        }
        Roof.initializeAt(curBiome, sx, sy - 4);
    }

    private void generatePlatforms()
    {
        //Goes through every column of blocks
        for (int x = 8; x < BIOME_WIDTH - 8; x += 2)
        {
            //Will try to build platforms between 6 blocks from the bottom of the map to 6 blocks above the highest piece of dirt on the map
            int compareTo = Math.max(6, maxHeights[x] - 6);
            for (int y = BIOME_HEIGHT - 6; y >= compareTo; y--)
            {
                //If there is 2 blocks of space above and below to build the platform
                if (curBiome[x][y].isAir() && curBiome[x][y + 1].isAir() && curBiome[x][y + 2].isAir() && curBiome[x][y - 1].isAir() && curBiome[x][y - 2].isAir())
                {
                    generatePlatform(x, y);
                }
            }
        }
    }

    private void generatePlatform(int x, int y)
    {
        int w = 1; 	//The width of the platform
        for (int ix = x + 1; ix < x + 7; ix++)
        {
            //If there are 2 blocks of space above and below to build the platform
            if (curBiome[ix][y].isAir() && curBiome[ix][y + 1].isAir() && curBiome[ix][y + 2].isAir() && curBiome[ix][y - 1].isAir() && curBiome[ix][y - 2].isAir())
            {
                w++;
            }
            else break;
        }

        //Platform must be at least 4 blocks wide and for every 10 places that there can be a platform, only 1 will be built
        if (w < 4 || rand.nextInt(25) != 0) return;

        for (int ix = x; ix < x + w; ix++)
        {
            curBiome[ix][y] = new Platform(ix, y, Platform.SubType.WATCH_TOWER);
        }
    }

    private void generateCheckpoint()
    {	//Tries to build a checkpoint the closest it can to the top right corner of the map
        for (int x = BIOME_WIDTH - 5; x > 0; x--) {
            for (int y = 7; y < BIOME_HEIGHT / 2; y++) {
                if (!curBiome[x][y].getType().equals("air")) {
                    generateCheckpointAt(x, y);
                    return;
                }
            }
        }
    }

    private void generateCheckpointAt(int x, int y)
    {	//(x, y) is the the bottom-left of the
        //Makes sure there is a block below the platform
        for (int ix = x; ix < x + 3; ix++) {
            if (curBiome[ix][y].getType().equals("air")) {
                curBiome[ix][y] = new Dirt(ix, y);
            }
        }
        //Build the base
        for (int i = 0; i < 3; i++) {
            curBiome[x + i][y - 1] = new Platform(x + i, y - 1, Platform.CHECKPOINT_BASE[i]);
        }
        //Builds the tower
        for (int i = 0; i < 5; i++) {
            curBiome[x + 1][y - 2 - i] = new Air(x + 1, y - 2 - i, "checkpoint", Air.CHECKPOINT_TOWER[i]);
        }
        //Adds the flashing lights
        curBiome[x][y - 2] = new FlashingAir(x, y - 2, FlashingAir.CHECKPOINT_LEFT_RED, FlashingAir.CHECKPOINT_LEFT_GREEN);
        flashingBlocks.addFlashingBlock(curBiome[x][y - 2]);
        curBiome[x + 2][y - 2] = new FlashingAir(x + 2, y - 2, FlashingAir.CHECKPOINT_RIGHT_RED, FlashingAir.CHECKPOINT_RIGHT_GREEN);
        flashingBlocks.addFlashingBlock(curBiome[x + 2][y - 2]);
        curBiome[x + 1][y - 7] = new FlashingAir(x + 1, y - 7, FlashingAir.CHECKPOINT_TOP_RED, FlashingAir.CHECKPOINT_TOP_GREEN);
        flashingBlocks.addFlashingBlock(curBiome[x + 1][y - 7]);

        checkpointRect = new Rectangle(x * BLOCK_WIDTH, (y - 7) * BLOCK_HEIGHT, 3 * BLOCK_WIDTH, 7 * BLOCK_HEIGHT);
        checkpointLights = new Point[] { new Point(x, y - 2), new Point(x + 2, y - 2), new Point(x + 1, y - 7) };
    }

    private void generateStartingPoint()
    {	//Finds a good location to generate a starting point
        int sumY = 0;
        for (int x = 0; x < 9; x++)
        {
            for (int y = 0; y < BIOME_HEIGHT; y++)
            {
                if (!curBiome[x][y].getType().equals("air"))
                {
                    sumY += y;
                    break;
                }
            }
        }
        int avgY = (int) (sumY / 9.0);
        generateStartingPointAt(4, avgY);
        spawnX = 4;
        spawnY = avgY;
    }

    private void generateStartingPointAt(int middleX, int platformY)
    {	//Makes the actual starting point
        curBiome[middleX - 4][platformY] = new Platform(middleX - 4, platformY, Platform.START_LEFT, Platform.SubType.START);
        curBiome[middleX - 3][platformY] = new Platform(middleX - 3, platformY, Platform.START_RIGHT, Platform.SubType.START);
        curBiome[middleX - 2][platformY] = new Platform(middleX - 2, platformY, Platform.START_LEFT, Platform.SubType.START);
        curBiome[middleX - 1][platformY] = new Platform(middleX - 1, platformY, Platform.START_RIGHT, Platform.SubType.START);
        curBiome[middleX][platformY] = new Platform(middleX, platformY, Platform.START_MIDDLE, Platform.SubType.START);				//Creates the platform
        curBiome[middleX + 1][platformY] = new Platform(middleX + 1, platformY, Platform.START_LEFT, Platform.SubType.START);
        curBiome[middleX + 2][platformY] = new Platform(middleX + 2, platformY, Platform.START_RIGHT, Platform.SubType.START);
        curBiome[middleX + 4][platformY] = new Platform(middleX + 4, platformY, Platform.START_RIGHT, Platform.SubType.START);
        curBiome[middleX + 3][platformY] = new Platform(middleX + 3, platformY, Platform.START_LEFT, Platform.SubType.START);

        for (int x = 0; x < 9; x++)									//Fills the blocks below the platform with dirt if they aren't already solid blocks
        {
            for (int y = platformY + 1; y < BIOME_HEIGHT; y++)
            {
                if (curBiome[x][y].getType().equals("air"))		//If air
                {
                    curBiome[x][y] = new Dirt(x, y);			//Replaces with dirt
                }
                else
                {
                    break;
                }
            }
            for (int y = platformY - 1; y > 0; y--)					//Fills the space above the starting platform with air
            {
                curBiome[x][y] = new Air(x, y);
            }
        }

    }

    private void generateBoxes()
    {	//This class generates the boxes that can be randomly found throughout the map
        //In the boxes there may be upgrades for the players
        for (int x = 5; x < BIOME_WIDTH - 5; x++)
        {
            for (int y = 10; y < BIOME_HEIGHT - 5; y++)
            {
                if (curBiome[x][y].getType().equals("air") && curBiome[x][y + 1].getType().equals("dirt") &&
                        !curBiome[x][y + 1].isTrenchBlock() && (int) (Math.random() * 10) == 0)
                {   /*
                        For an explosive to be placed at any location there must be:
                            - Dirt below it
                            - The dirt cannot be a trench block
                            - Air at its current location
                    */
                    curBiome[x][y] = new Box(x, y);
                }
            }
        }
    }

    private void generateExplosives()
    {	//This class generates the explosives that can be randomly found throughout the map
        //In the explosives there may be upgrades for the players
        for (int x = 5; x < BIOME_WIDTH - 5; x++)
        {
            for (int y = 10; y < BIOME_HEIGHT - 5; y++)
            {
                if (curBiome[x][y].getType().equals("air") && curBiome[x][y + 1].getType().equals("dirt") &&
                        !curBiome[x][y + 1].isTrenchBlock() && (int) (Math.random() * 20) == 0)
                {   /*
                    For an explosive to be placed at any location there must be:
                        - Dirt below it
                        - The dirt cannot be a trench block
                        - Air at its current location
                    */
                    curBiome[x][y] = new Explosive(x, y);
                }
            }
        }
    }

    private void generateEnemySoldiers()
    {   //Generates random enemy soldiers
        for (int x = 10; x < BIOME_WIDTH - 5; x++)
        {
            for (int y = 10; y < BIOME_HEIGHT - 5; y++)
            {
                if (!curBiome[x][y].canShootThrough() && curBiome[x][y - 1].canShootThrough() &&
                        curBiome[x][y - 2].canShootThrough() && (int) (Math.random() * 12) == 0)
                {
                    Enemy e = new EnemySoldier(x * BLOCK_WIDTH, y * BLOCK_HEIGHT);
                    enemies.put(e.creationTime, e);
                    pause(5);
                }
            }
        }
    }

    //-----------------------------------------------------------------------------------------------------------------------------

    //-----------------------------------------------------------Collisions--------------------------------------------------------
    //This area contains methods for removing blocks when they are destroyed

    public void destroyBlock(int x, int y, Direction d)
    {	//Destroys the block and fills that spot with air
        Color col = curBiome[x][y].getParticleCol();	//Gets the Color of the particles shot off

        //If the block is dirt there is a small chance that a metal block will be generated in its place
        //The purpose of this is to allow the player stepping stones to still be able to move around destroyed sections of the map
        if (curBiome[x][y].getType().equals("dirt") && (int) (Math.random() * 25) == 0) {
            curBiome[x][y] = new Platform(x, y, Platform.METAL);
        } else curBiome[x][y] = new Air(x, y);			//Replaces the block with air

        g = img.getGraphics();
        curBiome[x][y].draw(g);					//Draws air at its place
        for (int i = 0; i < 10; i++)
        {	Particle.makeParticle(x * BLOCK_WIDTH, y * BLOCK_HEIGHT, d, col);	}
    }

    //-----------------------------------------------------------------------------------------------------------------------------

    //---------------------------------------------------------Accessor Methods----------------------------------------------------
    //Returns the Array of Arrays representing every block in the biome
    public Block[][] getBiome()
    {
        return curBiome;
    }

    //Returns the Graphics of the biome's image
    public Graphics getGraphics() { return img.getGraphics(); }

    //Returns the Blocks in the GameMap that flash
    public FlashingBlocks getFlashingBlocks() { return flashingBlocks; }

    public Block getAt(int x, int y)
    {
        return curBiome[x][y];
    }

    //Returns the LinkedList of enemies
    public HashMap<Long, Enemy> getEnemies() { return enemies; }

    //----------------------------------------------------Player Spawning Methods--------------------------------------------------

    public int getSpawnX()
    {	//Returns the x-coordinate of the Player's initial position
        return BLOCK_WIDTH * (spawnX + (int) (Math.random() * 6.0 + 0.5) - 3);			//Somewhere random on the start platform
    }

    public int getSpawnY(int h)
    {	//Returns the y-coordinate of the Player's initial position
        return spawnY * BLOCK_HEIGHT - h;
    }

    //-------------------------------------------------------Checkpoint Methods----------------------------------------------------

    public boolean checkIfReachedCheckpoint()
    {
        if (!hasReachedCheckpoint)
        {	//If no player has reached the checkpoint yet
            LinkedList<Player> players = Player.getPlayers();
            for (Player p : players)
            {
                if (checkpointRect.intersects(p))
                {
                    hasReachedCheckpoint = true;
                    for (Point po : checkpointLights)
                    {
                        ((FlashingAir) curBiome[po.x][po.y]).swapImgs();
                    }
                    return true;
                }
            }
        }
        return hasReachedCheckpoint;
    }

    //------------------------------------------------------------Drawing----------------------------------------------------------
    public void updateSubMap(Graphics g)
    {	//Updates the SubMap so the the image encompasses all of the players
        LinkedList<Player> players = Player.getPlayers();
        double numPlayers = (double) players.size();
        int sumX = 0;		//The sums of the coordinates of the player
        int sumY = 0;

        for (Player p : players)	//Adds the coordinates of each player
        {
            sumX += p.getX();
            sumY += p.getY();
        }

        int avgX = (int)((double)sumX / numPlayers);		//The average position of the player
        int avgY = (int)((double)sumY / numPlayers);

        int maxDistSq = 0;						//The max distance between the avg pos and a player
        int maxX = 0; int maxY = 0;					//That player's position
        int dx = 0; int dy = 0;							//The distance between the avg pos and the player pos
        for (Player p : players)				//Goes through each player to see which one is the furthest from the average
        {
            int tx = p.getIntX();
            int ty = p.getIntY();
            dx = avgX - tx;
            dy = avgY - ty;
            int curDistSq = (dx) * (dx) + (dy) * (dy);		//The distance squared between the avg and player
            if (curDistSq >= maxDistSq)						//(Square root is $$$)
            {
                maxDistSq = curDistSq;
                maxX = tx; maxY = ty;
            }
        }
        int lx, ty, width, height;
        if (players.size() <= 1)
        {   /*
                How the map is displayed in single player is slightly different than multiplayer
                in sigle
            */
            width = sm.getWidth();
            height = sm.getHeight();
            lx = Math.min(Math.max(avgX - width / 2, 0), BIOME_WIDTH * BLOCK_WIDTH - width);
            ty = Math.min(Math.max(avgY - height / 2, 0), BIOME_HEIGHT * BLOCK_HEIGHT - height);
            subMap.setAll(lx, ty, width, height, ImageTools.copy(img.getSubimage(lx, ty, width, height)), true);
        }
        else {
            if (Math.abs(maxY - avgY) >= Math.abs(maxX - avgX))    //If the y-dist from avgY is greater than the x-dist from avgY
            {
                height = 2 * (Math.abs(dy) + 6 * BLOCK_HEIGHT);                        //The height of the img is calculated first
                width = (int) ((sm.getWidth() / (double) sm.getHeight()) * height);    //And width is scaled after so that it holds the same
                //Resolution ratio of the screen
            } else {
                width = 2 * (Math.abs(dx) + 6 * BLOCK_WIDTH);
                height = (int) ((sm.getHeight() / (double) sm.getWidth()) * width);
            }

            //Calculates the top-left coord of the img
            lx = Math.min(Math.max(0, avgX - width / 2), BIOME_WIDTH * BLOCK_WIDTH - width);
            ty = Math.min(Math.max(0, avgY - height / 2), BIOME_HEIGHT * BLOCK_HEIGHT - height);
            if (lx < 0)
                lx = 0;                                    //Handles special cases when the map is very zoomed out
            if (ty < 0) ty = 0;
            width = Math.min(width, BIOME_WIDTH * BLOCK_WIDTH - 1);
            height = Math.min(height, BIOME_HEIGHT * BLOCK_HEIGHT - 1);
            //Updates the SubMap
            subMap.setAll(lx, ty, width, height, ImageTools.copy(img.getSubimage(lx, ty, width, height)), true);
        }
    }

    public static void main(String[] args) {
        new GameMap(null);
    }
}

//This class contains the portion of the GameMap that will be drawn on the screen at the current frame
//It allows other classes to draw their objects onto the current screen frame at their real size before the SubMap
//Is scaled down to fit on the screen
class SubMap extends Rectangle
{
    private BufferedImage img;							//The sub-image of GameMap.img which contains all of the players in it
    private StateManager sm;							//The JFrame of the game, used to get the resolution of the screen
    private Graphics g;									//The Graphics object to draw on the img

    protected Rectangle updateRect;                     //If the Enemies are contained inside this Rect they are worth updating

    protected boolean shouldScale;                          //In single-player the image does not need to be scaled

    public SubMap(StateManager s)
    {
        super(0, 0, 0, 0);
        updateRect = new Rectangle(0, 0, 0, 0);
        sm = s;
    }

    public void setAll(int nx, int ny, int nw, int nh, BufferedImage bi, boolean ss)
    {	//Called every frame when GameMap is done calculating what of the game map is to be drawn that frame
        x = nx; y = ny; width = nw; height = nh; img = bi; g = bi.getGraphics();
        updateRect.x = x - width / 2; updateRect.y = y - height / 2; updateRect.width = 2 * width; updateRect.height = 2 * height;
        shouldScale = ss;
    }

    public int getIntX()	{	return x;	}						//Returns the top left corner of the img relative to the entire
    public int getIntY()	{	return y;	}						//Game map
    public int getIntWidth()	{	return width;	}
    public int getIntHeight()	{	return height;	}				//Rectangle.getX(), etc... return doubles, removes the pain of having
    public BufferedImage getImg()	{	return img;	}				//To cast it down to an int
    public Graphics getGraphics()	{	return g;	}

    public BufferedImage getScaledImg()
    {	//Returns the image scaled such that it will fit completely on the screen
        BufferedImage toReturn;
        if (shouldScale)
            toReturn = ImageTools.scale(img, (double) sm.getWidth() / width, (double) sm.getHeight() / height);
        else toReturn = img;
        return toReturn;
    }

    public Rectangle getUpdateRect()
    {   //Returns a Rectangle that is slightly larger than what the Players see onscreen
        //This should make the game more efficient as not every Enemy has to be updated in its entirety every frame
        return updateRect;
    }
}